ctrl + shift + i  vscode格式化

弹性盒子
/* 如果几个元素是块状元素，但是如果放置在弹性盒子中，他们的块状元素特性就会消除 */
/* 设置容器为弹性盒子 */
.container{
	display: flex;
	/* 设置容器下的子项item的排布方向及排序  column row*/
	flex-direction: row;
	height: 400px;
	background-color: #9999;
	/* 主轴和交叉轴 */
	/* 当flex-direction为那个方向时，那个方向就是主轴 */
	/* 主轴 设置对齐方式 常用五种  start end center space-between space-around       reverse后相反*/
	justify-content: center;
	/* 交叉轴 设置对齐方式  start end center stretch(没有高度时 拉伸高度) baseline(每个元素里的文字底线对齐 按照第一个对齐)       reverse后相反*/	
	/* align-items: flex-start; */
	/* 设置换行  当设置的宽度大于屏幕宽度时flex会平均分配每个items宽度不会出现换行 */
	/* flex-wrap: wrap; */
}


"usingComponents": {
    "like-cmp" : "components/like/index"   //在page中引入组件
  }


  images组件如果不设置高和宽  小程序会给其设置默认高和宽

  rpx 


  组件只继承极少数的全局样式  如 font  color

  点击事件 bind:tap="onLike"   catch:tap(会冒泡) 方法写在js的mothods中

  组件分为外部属性和内部属性  外部属性一般定义在properties中  内部属性在data中

  小程序生命周期函数


  es6之前回调函数中使用this需要在外部用that=this接受 传入内部   es6可以  =>(res){}  箭头函数传入
  es6的模块导入导出  export  import(导入时只能使用相对路径)

  回调函数
     let latest = classic.getLatest((res)=>{
          console.log(res)
          this.setData({
            classicData:res
          })
    });

      getLatest(sCallback){
        let a = ''
        this.request({
            url: 'classic/latest',
            success: (res) => {
                sCallback(res)
            }
          })
    }


    将组件需要的数据通过组件的属性传递到组件内部进行处理
  
    页面渲染流程    API->page页面的js(setData)->page页面(传入组件属性)->组件的js(setData)->组件页面

    不光setData的数据页面可以读取  data中的也可以